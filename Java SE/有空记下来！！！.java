标识符: 
		在java程序中有些名字是可以自定义的，那么这些自定义的名字我们就
		称作为自定义的标识符。

标识符要注意的细节：
		1. 标识符的组成元素是由 字母（a-zA-Z） 、数字(0-9) 、 下划线(_)、 美元符号($).
		2. 标识符不能以数字开头。//字母 数字 下划线 美服
		3. 标识符是严格区分大小写的。
		4. 标识符的长度是没有长度限制的。
		5. 标识符的命名一般要有意义（要做到让人见名知意）
		6. 关键字、保留字不能用于自定义的标识符。

自定义标识符的规范：
	1. 类名和接口名单词的首字母大写，其他单词小写。 比如： RunTime.
	2. 变量名与方法名首单词全部小写，其他单词首字母大写，其他小写。  比如： doCook()；
	3. 包名全部单词小写。
	4. 常量全部单词大写，单词与单词之间使用下划线分隔。  比如： UP_DIRECTION
	

判断一下那些是 符合的标识符:
	12abc_   不合法  数字不能开头
	_12abc    合法
	$ab12#    不合法  #号不属于标识符组成元素。
	abc@123   不合法  @号不属于标识符组成元素。 


关键字：
		关键字就是在java程序中具备特殊含义的标识符。关键字一般用于描述一个程序的
		结构或者表示数据类型。

注释： 
		注释就是使用文字对程序的说明，注释是写给程序员看的，编译器会忽略注释的 内容的。

注释的类别：
	
		第一种： 单行注释。   // 注释的内容

		第二种： 多行注释。   /* 注释的内容  */

		第三种： 文档注释.    /** 注释的内容  */

		文档注释也是一个多行注释。


	细节：
		1. 单行注释可以嵌套使用，多行注意是不能嵌套使用的。

	作用：
		1. 使用文字对程序说明。
		2. 调试程序。


软件 =  数据 + 指令 + 文档(使用者文档+ 开发者文档)


多行注释与文档注释的区别： 
	 1.多行注释的内容不能用于生成一个开发者文档，
	 2.而文档注释 的内容可以生产一个开发者文档。



	
javadoc工具的使用格式： (生成开发者文档)
		

		javadoc -d 存放文档的路径   java的源文件 
	

	注意：
		1. 如果一个类需要使用javadoc工具生成一个软件的开发者文档，那么该类必须使用public修饰。
		2. 文档注释注释的内容一般都是位于类或者方法的上面的。

写注释的规范：一般单行注释是位于代码的右侧，多行注释与文档注释一般是写在类或者方法的上面的。

写法如下：
	/*
		该类是用于模拟QQ软件的
		@author 1208JAVA基础班全体同学
		@version 1.0
	*/
	public class Demo3 {  //一般的都是 cless 类名
		/**
		  操作的流程如下：
			1.首先先输入用户名密码
			2. 校验用户名与密码
			3. 展示好友列表			
		*/
		public static void main(String[] args) {
			System.out.println("请输入用户名与密码");  //这句话是用于输入用户名与密码的。
			System.out.println("校验用户名与密码");
			System.out.println("展示好友列表");
	}}

常量: 
		常量就是程序在运行过程中其值不能发生改变的量。

常量的类别：
		整数常量   10 12
		小数常量	3.14
		布尔常量   布尔常量只有两个值： true（"tu e"）(正确). false（"fo si"）(错误)
		字符常量   字符常量就是单个字符使用单引号引起来的内容我们称作为字符常量。
		字符串产量  字符串常量就是使用双引号引起来的内容称作为字字符串常量。

---------------------
整数常量的表现形式：
						整数的表现形式主要是以不同的进制(二进制、八进制、十六进制)表现出来。

	进制： 
			十进制（0~9） 、 星期（七进制 0~6）、 小时(12进制(0-11)、 24进制(0~23))

	进制：
			用有限的数字符号代表所有的数值。

	计算机的出现是为了服务于人类的，那么人类在现实生活中使用的数据基本上都是
	十进制的数据，那么计算机是否有可以存储现实生活中的数据呢？如果可以存储
	又以哪种形式存储呢？


二进制：

	由来：
		电脑记录我们现实生活中的数据都是使用二进制进行记录的，那么我们
		就要懂得如何把十进制数据转换成二进制。

		
	转换：
			
		十进制转二进制的方法：
			使用十进制的数据不断除以2，直到商为0为止。从"下往上取余数"就是
			对应的二进制。 
			
			2(十进制)-------->10(二进制）

		二进制转十进制:
			使用二进制的每一位乘以2的n次方，n从0开始，每次递增1，然后把各部分的数据
			相加即可。
			
			 1110(二进制) ---------> 14(十进制)
		
	弊端： 二进制的书写太长了，不方便人类记忆。

	特点： 由0~1组成。

		
		
		
		解决方案：每三个二进制位就就记录一个数字。

		1000（十进制）------> 001,111,101,000（二进制） = 1,7,5,0
	
	
	一个八进制的数据就是相当于三个二进制位。

八进制：

	转换：

			十进制转八进制:使用十进制的数据不断除以8，直到商为0为止。从下往上取余数就是
			对应的八进制。
				
				45(十进制)------>  55 （八进制）

			八进制转十进制：使用八进制的每一位乘以8的n次方，n从0开始，每次递增1，然后把各部分的数据
			相加即可。
						
				23(八进制)------>    (十进制)
	
	特点： 只有0~7这八个字符组成的。

十六进制：
	
	十六进制的数据: 0~9 , a（10）, b(11), c(12), d(13), e(14), f(15)， 四个二进制位就是一个十六进制的数据.

	十六进制的数据是有0~9、a-f这几个字符组成的。

	
		十进制转换成十六进制:使用十进制的数据不断除以16，直到商为0为止。从下往上取余数就是
			对应的十六进制。

			38(十进制)---->26  （十六进制）

		十六进制转十进制：使用十六进制的每一位乘以16的n次方，n从0开始，每次递增1，然后把各部分的数据
		相加即可。

			34(十六进制)-----> 52（十进制）


class Demo4{

	public static void main(String[] args){
		/*
		System.out.println(12); //整数常量
		System.out.println(3.14); //小数常量
		System.out.println(false); //布尔常量
		System.out.println('1'); //字符常量
		System.out.println("hello world"); //字符串常量

		如果一个数据没有加上任何的标识之前，默认就是十进制的数据。
		*/
		System.out.println(10);// 十进制
		System.out.println(0b10); //二进制 , 如果一个数据要表示二进制，那么要在该数据的前面加上0b开头。
		System.out.println(010); //八进制数据， 八进制的数据需要以0开头
		System.out.println(0x10); //十六进制数据， 十六进制的数据需要以0x开头
	}
}




if 语句 格式：

		if (判断条件)
			{    符合条件
			}else if (判断条件)
			{	符合条件	
			}else { 不符合条件 }
		注意：
			1. 如果符合条件后只有一个语句需要执行，那么可以省略大括号。但是建议不要省略，因为结构不清晰。
			2. if语句的判断条件后不能添加分号，否则会影响到执行的效果的

三元运算符 格式：
		
		布尔表达式？值一：值二; 
		
			   1==1？ true：false;




static (静态、修饰符)
	static修饰成"员变量"： 静态 共享 一份数据

	方式：
		一： 可以使用对象访问。
			对象.属性名
		二：可以使用类名访问。
			类名.属性名

	注意：	
		1.非静态成员不能使用 类名直接访问，要用对象访问。
		2.千万不要为了访问方便而用static修饰。一定要数据正真是需要被共享的时候才可以使用static修饰.

	static修饰"成员函数"：
			静态函数的访问方式
			一：可以使用对象访问
					对象.属性名
			二：可以使用类名访问
				类名.属性名
	建议使用类名访问静态的成员


	"静态函数"注意：
			1.非静态函数只能有对象调用，函数可以由类名或者对象进行调用。
			2.静态函数中不能直接访问非静态成员，可以直接访问静态成员。
			3.非静态函数可以直接访问非静态成员，也可以直接访问静态成员。
			4.静态函数中不能出现 this或super 关键字

			我的看法：				被谁调用	|	能访问谁
												|
						静态：		对象、类名	|	静态				静态是共有一份    				
						非静态：	对象		|  静态、非静态			非静态是私有的  多份
				
						静态不可以出现关键字

super 关键字：代表父类的引用空间。

	   作用：
			1.如果子父类存在同名成员时，
			在子类中默认是访问子类的成员，
			可以通过super关键字访问指定调
			用父类的构造行数

			2.创建子类对象时，默认会先调用
			父类的无参构造函数，可以通过
			super关键字访问指定调用子类的
			构造行数
		
		注意：
			1.如果在子类的构造函数中没有指定调用具体父类构造函数，那么java编译器会在子类构造函数上添加super()
			2.super 必须在第一个语句
			3.this 和 super 不能同时出现在同个构造函数中，都是要第一条语句



方法重载：
			子父类存在同名的函数

重写需求：如果父类功能的无法满足子类的需求，就重写

方法重写的要数：
			1."函数名与形参列表"必须一致
			2.子类的权限修饰符必须大于或等于父类 权限修饰符
			3.子父类的返回类型必须小于或等于父类返回值类型
			4.子父类的异常类型必须小于或等于父类的异常类型





instanceof ：判断一个对象是否属于某种类型
        格式：
		对象 instanceof 类

        使用前提：判断类的对象与类型 必须存在继承或者实现 关系

抽象类：
		是么时候用： 描述一类事物的时候，发现该事				  
		物确实存在某种行为，但是目				  
		前这种行为不具体，这时候应该				  
		抽取这种行为的声明而不去实				  
		现这种行为，此时称为抽象的行				  
		为，要用抽象类。
		
		注意：
			1.如果一个方法没方法体，那么该方法必须用abstract修饰
			2.如果一个类函数抽象方法，那么这个类肯定是一个抽象类或接口
			3.抽象类是含有构造方法
			4.抽象类不能创建对象
			5.抽象类可以存在非抽象方法与抽象方法
			6.抽象类可以不存在抽象方法
			7.非抽象类继承抽象类的时候，必须要把抽象类中所用方法全部实现

abstract 与 以下关键字结合：
			static 共同修饰一个方法
			private 共同修饰一个方法
			final 共同修饰一个方法
		




接口： 
		格式：
				interface 接口名
				{		成员变量
						成员函数
				}
				
		作用：
				1.程序解耦
				2.定义规范约束
				3.扩展功能

	注意细节：
				1.接口中成员变量都是常量，默认： public static final.
				2.接口中的方法全部都是抽象的方法， 默认是 public abstract
				3.接口不能创建对象
				4.接口没有构造函数
				5.非抽象类通过 implements （yin pe li mensi）实现接口的时候，必须把接口中的所有方法实现

--------------------
权限修饰符

public				  公共的				大
protected	pe te ta pe	  受保护的
default    di fo de   缺省 默认			 |
private               私有的				小	

权限修饰符 控制被修饰的成员的范围可见性

			public		protected		default		private 
						
	
同一个类	true		true			true		true

同一个包	true		true			true		false
		
子父类		true		true			false		false

不同包		true		false			false		false



注意 在不同包下 只有 public 与 protected 可以反问， protected 必须是在继承关系下才能访问
----------------------
--------------------------
关键字

super 代表副类空间的引用

      作用 ： 
			1.子父类存在同名成员时，在子类中默认是访问子类成员变量，可以通过super关键字指定访问父类的成员。
			2.指定调用父类的构造方法。 ()判断有无参数
		
调用父类构造方法要注意：
			1.如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在构造方法上面加 super(); 语句。
			2.super 调用父类，在子类构造函数中必须是第一个语句

super 必须出现在子类构造方法里


	
	this();指定调用无参的构造方法
	super();//指定调用父类无参构造方法

	1.都必须是第一条语句 且 调用其他构造方法
	2.不可以同时出现在 同个构造函数中
	3.super 存在继承关系 出现在子类构造方法里 调用父类       extends
	  this  指的都是 本类 的 成员变量
------------------------
面向对象三大特征：
	1. 封装
	2. 继承
	3  多态。

需求：  使用java类描述百合网的会员。

问题： 性别有问题？？

根本原因： 由于其他人可以直接操作sex属性。可以对sex属性进行了直接的赋值。

封装:


权限修饰符：权限修饰符就是控制变量可见范围的。

public :  公共的。 public修饰的成员变量或者方法任何人都可以直接访问。

private ： 私有的， private ( pe ai like )修饰的成员变量或者方法只能在本类中进行直接访问。


封装的步骤：
	1. 使用private修饰需要被封装的属性。
	2. 提供一个公共的方法设置或者获取该私有的成员属性。
			 命名规范：
				set属性名();
				get属性名(); 

疑问： 封装一定要提供get或者set方法吗？
		不一定， 根据需求而定的。

规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。

实体类：实体类就是用于描述一类 事物的就称作为实体类。


工具类(Arrays数组的工具类):


封装的好处：
	1. 提高数据的安全性。
	2. 操作简单。 
	3. 隐藏了实现。

------------------------------
继承
	
	格式： class 类名1 extends 类名2{
			}
	
	注意：
		1.父类私有对象的成员不能被继承
		2.父类构造函数不能被继承
		3.创建子类对象时，默认会先调用的无参构造函数，然后调用子类的构造函数
---------------------------------------

多态：父类的引用类型变量指向 子类的对象 
		或者是  接口类型的引用类型变量
		指向了 实现类的对象.


		多态存在于 继承 和 实现类



实现关系下的多态：

	接口 变量 = new 接口实现类的对象


	instanceof   (is tens of)

前提：	对象与类之间必须存在继承关系 或 实现关系	

作用：	1.判断对象是否属于指定类别。
	----2.多态中，做类型转化时都要先判断在转换。 
   
格式：只能是 （对象  instanceof 类名 ） true false   不然就报错 

多态的应用：
  1. 多态用于形参类型的时候，可以接收更多类型的数据 。
  2. 多态用于返回值类型的时候，可以返回更多类型的数据。



多态的好处： 提高了代码的拓展性。

需求1： 定义一个函数可以接收任意类型的图形对象，并且打印图形面积与周长。


    抽象类：某各类的方法不正确，要强制其重写


-------------------------------------
问题：
	   1.动物的run方法不正确
	   2.没有强制子类一定要重写run的方法

抽象类：
		作用：强制子类方法重写
		
	注意：
		1.如果一个函数没有方法主体，那么该函数必须要用abstract修饰成，抽象的函数
		2.如果一个类出现了抽象类，那么必须该类也必须 使用abstract修饰
		3.如果一个非抽象类继承了抽象类，那么必须要把抽象类的所用抽象方法全部实现
		4.抽象类可以存在非抽象方法，也可以存在抽象的方法
		5.抽象类不能创建对象。 因为抽象类存在的抽象方法的，如果能让抽象类创建的话，
		  那么使用抽象的对象调用抽象的方法是没有任何意义的。

		6.抽象类是存在构造函数的，其结构是提供给子类创建对象的时候初始化父类的属性

抽象类注意：
       1.一个函数没有方法主体，那么该函数必须用abstract修饰， 称为抽象类
	   2.如果一个函数是抽象类，那么该类也必须用abstract修饰
	   3.如果一个非抽象类继承了抽象类，就要写出对应且不含abstract的构造方法
                  (abe sique de)

abstract不能与以下关键字组合：
		1.不以private（plai ruike）共同修饰一个方法      私有出了这个类就不可见
		2.不以static（sa ti ke）共同修饰一个方法         别人可以使用类名进行调用
		3.不以final（fai no）共同修饰一个方法            又是最终 又要重写

----------------------------
反编译： javap -c -l -private 类名


接口：
	注意：
		1.接口是个特殊的类
		2.接口成员变量默认的修饰符为： public static final    （成员变量都是常量）
		3.接口中的方法都是抽象的方法，默认修饰符为：public abstract（abe sique tr)
		4.接口不能创建对象
		5.接口是没有构造方法的
		6.接口是给类去实现使用的，非抽象类实现一个接口是，必须把 所有接口的方法全部实现

	格式：        （in peli mensi）
		class  类名 implements  接口名{
		}
	
	
	作用： 
		1.具有扩展功能
		2.定义约束规范
		3.程序的解耦


 常数：一声明就要定义
--------------------------------
其他方法


	替换	String replace(String oldChar,String newChar)   
	切割	String[] split(String regex)

	指定 开始与结束的 索引值 取子串
			String substring(String beginIndex, int endIndex)

	String toUpperCase()   转大写
	String toLowerCase()   转小写
	String trim()		   去除空格




"==" 比较内存地址
"x1.equals（x2）" 比较 x1  x2的是内容，默认情况下比较两个对象的内存地址
				尽量保证 x1 是常量。

笔试题目：new String("abc")创建了几个对象？
两个对象，一个位于字符串常量词中，一个对象位于堆内存中

----------------------
---------------------
内部类： 一个定义在另外一个类的内部，那么该类就称作内部类

内部类的class文件名：外部类$内部类。   利于：便于区分class文件是属于哪个外部类
内部类的类别：
	
成员内部类：

方式
		1：在外部类 提供一个方法创建内部类的对象进行访问。

		2：在其他类 直接 创建内部类的对象。 
	
	格式 ：	外部类.内部类  变量名 = new 外部类().new 内部类
							
	注意：如果是一个静态内部类，那么在其他类 创建的格式：
		
		
		外部类.内部类 变量名 = new 外部类.内部类();


内部类引用场景：我们在描述A类事物的时候，发现描述A事物内部还存在另外一个 比较
				 复杂的事物B时候， 而且这个比较复杂事物B还需要要访问A事物的属性等数据，那么这时
			 	 候 我们就可以使用内部类描述B事物
							
						
内部类的好处： 内部类可以直接访问外部类的所用成员 （悟空进牛魔王的肚子）
								
		注意：	1.外 内 部类 都存在同名变量时，在内部类中默认访问的是内部类的成
				员变量（就近原则）， 可以通过   外部类.this.成员变量名 访问指定变量
				
				2.私有的成员变量 只能在外部类提供一个方法创建内部类的对象  进行
				访问，不能再其他类创建对象了.
				
				3.成员内部类出现类静态的成员，那么  该类需要用staic修饰
				原因：	
		
		
		
		
局部内部类：在一个类的 方法内部定义另一个类， 那么另一个类就是方法内部类.

---------------------------
学一个体系时：都是从上往下学   


	异常体系：
				  Throwable 所有错误类的超类					Throwable Error Exception				
			     （qua bou）
			     |	      |
		Error 错误		Exception 异常								
		（ a e ）	        |（E sai shen）|
				     运行异常		 编译异常




（抛出）											作用
Throwable
	toString()				  字符串           返回当前异常对象的完整类名
	getMessage()  （Me shi ju） 得到消息		返回创建Throwable传入的字符创信息
	printStackTrace() （printsida qunsi）			打印异常的栈信息

异常类			一般都会通过代码去处理
Exception  （esha shen）  
	ArithmeticException		算术异常  （e ruitemen tiE sai shen）
	NullPointerException	空指针异常 （Nen pote E sai shen）
  
  RuntimeException
	运行时异常：如果一个方法内部抛出一个运行时异常，那么方法上可以 处理或不处理
	编译时异常：如果一个方法内部抛出一个编译时异常对象，那么方法上就必须要声明，调用者也必须处理
				     （runtai Exception ）
		运行时异常： RuntimeException 以及 其子类都属于运行时异常
		编译时异常： 

错误类    一般由 jvm 或者是 硬件 引发的问题，所以我们一般不会通过代码去处理
Error



如何区分错误与异常：
	如果程序出现不正常的信息，如果不正常的信息的类是以Error结尾，那么肯定是一个错误。
	如果是以Exception结尾的，那么肯定是一个异常
		    （esha shen）
------------------
finally 块(fai ne li)
		使用前必须存在try块
		任何时候都会执行 只有jvm退出时会停止执行
		常用于资源释放的工作，可以保证资源在任何时候都可以被释放

三种组合：
	1.用于有异常要处理，但没有资源的释放
			
		try{
			可能发生异常的代码
		}catch （捕获的异常类型 变量名）{
				处理异常		
		}
		
	2.有异常要处理，要资源释放

		try{
			可能发生异常的代码
		}catch （捕获的异常类型 变量名）{
				处理异常		
		}finally{
				释放资源的代码；		
		}

	3.内部抛出的是运行时异常，需要资源释放  （ 少用 ）

		try{
			可能发生异常的代码
		}finally{
				释放资源的代码；

		编译时异常就一定要处理 运行时异常可以不用处理

----------------------------
java 面向对象语言 找适合对象 做适合事情
  
  方式一： 自定义类 然后同过自定义的类创建对象
  方式二： sun提供许多类使用， 我们只需认识      通过类 来创建
  
  
  Object 是所有类的父类 
  
  
  Object 类：
  		toString（）   	返回对象字符表示
  						作用：
  							
		equals（Object obj）  用于比较内存地址，判断对象是否相同
  		hashCode



 String()  构造方法：
 
 		String() 创建一个空内容 的字符串
 		String(bye[] bytes) 使用一个字节数组构建一个字符串对象
 
 
 		替换		String replace(String oldChar,String newChar)   
 		切割		String[] split(String regex)

 		指定 开始与结束的 索引值 取子串
				String substring(String beginIndex, int endIndex)
				begin Index 
				end   Index
				
				String toUpperCase()   转大写
				String toLowerCase()   转小写
				String trim()		   去除空格

-----------
System 系统类 		主要用于获取系统的属性 数据

			arraycopy(Object src, int srcPos, Object dest, int destPos, int length )
				src  		源数组(数组的名字)
				srcPos 		 源数组   开始复制的位置
				dest		存放在 目标数组
				destPos 	在目标数组    开始粘贴的	起始位置
				length		在目标数组    开始粘贴的	束的位置
				
(重点)		currentTimeMillis() 	获取系统时间 （毫秒）
				
(一般)		exit(int status)		退出jvm  如果参数是0表示正常退出jvm，非0表示异常退出jvm	
			gc()			建议jvm快速启动jvm 回收垃圾
			getenv(String name)  根据环境变量的名字    获取环境变量
			getProperty(key)	

---------
RunTime   该类  主要代表了应用程序运行环境

	
		getRunTime()   返回当前引用程序的运行环境对象。
		exec(String command)	根据指定的路径执行对应的可执行文件
		freeMemory()   返回jvm 中空闲的内存量    以字节单位
		maxMemory()    返回jvm 试图使用的最大内存量
		totalMemory    返回jvm 中内存总量
		
-----------
日期类    	Date				(deite)
		
		Calendar
		
日期格式化类
		SinpleDateFormat   	(sinde deite feme) 
		
		作用：
			可以把  日期	转换为指定格式的字符串   	format()
			可以把  一个字符串	转化为对应的日期	parse()
		
		默认格式: SimpleDateFormat	dateFormat	= new SimpleDateFormat();

-----------
字符串特点；字符串是常量，他们的值在创建之后不能更改
 
 一点变化 就会创建一个新的对象
 注意： 字符串的内容频繁修改，因为一旦 就会创建一个新对象    
 
 频繁修改 建议使用字符串缓冲类       
 -------------------------------------------------------
 缓冲类  stringBuffer  其实就是储存字符的一个容器
 
 笔试题目： 使用stringbuffer无参的构造函数创建一个对象是， 默认的初始容量是对少？如果长度不够使用，自动增长多少倍？
 		stringBuffer  底层是依赖了一个 字符数组才能 储存字符数据的， 该字符串数组默认的初始值容量是16， 长度不够用 自增长一倍
 		

 StringBuffer:


 		容器具备 的行为      
 			
 			增加   
(a pende)	 	append(boolean b)   可以添加任意类型  数据到容器中
(in sete)		insert(int offset, boolean b) 指定插入的索引值，插入对应的内容
 		
 			giy
 			删除
（de lite）		delete(int start, int end)  	根据指定的开始和结束的索引值删除对应的内容。
 				deleteCharAt(int index)			根据指定的字符删除一个字符
 				
 			
 			
 			修改    
 （rui pelei）	replace(int start, int end, String str) 根据指定的开始也结束的索引值   替代指定内容
（V wuesi）		reverse()						反转字符串的内容
 				setCharAt(int index, char ch)	根据索引值 替换单个字符
 				substring(int start, int end)	根据指定的索引值 	截取子串
    			ensureCapacity(int minimumCapacity)		指的StringBuffer内部的字符数组长度的
 			 
 			 查询 
 			 indexof(String str, int fromIndex) 		查找指定字符串    第一次出现的索引值，并且指定开始查找的位置  
 			 capacity()									查看当前字符数组的长度	
 			 charAt(int strm, int fromIndex)
 			 lastIndexOf(String str)
 			 length()			多用于遍历数组
 			 toString()									  把字符串的内容转换为 字符串 返回
 			 
 			 
 			 
 StringBuffer 与  StringBuilder 的相同之处 
  			相同：
  				两个类都是字符串缓冲流
  				两个类都是方法都一致
 			不同点：
 				StringBuffer 是线程安全的,StringBuilder是线程非安全.
 			 StringBuffer是JDK1.0出现的   StringBuilder是JDK1.5出现的。
 			 
 			 
 			 建议使用StringBuilder，操作效率高

------------------------
枚举：一些方法在运行时，它需要的'数据不能是任意的，而必须是一定范围内的值'，可以直接使用枚举予以解决。


枚举类的定义格式：
	
	enum 类名{
	man,woman //枚举值         定义了两个枚举值
	}
				
	 			
				
枚举要注意的细节：
	1. 枚举类也是一个特殊的 类。
	2. 枚举值默认的修饰符是public static final。(常量)
	3. 枚举值就是是枚举值所属的类的类型， 然后枚举值是指向了本类的对象的。
	4. 枚举类的构造方法默认的修饰符是private的。
	5. 枚举类可以定义自己的成员变量与成员函数。
	6. 枚举类可以自定义构造函数，但是构造函数的修饰符必须是private。
	7. 枚举类可以存在抽象 的方法，但是枚举值必须要实现抽象 的方法。
	8. 枚举值必须要位置枚举类 的 '第一个语句'。


-----------
单类设计模型：保证一个类在内存只有一个对象。

饿汉单例设计模型：
		1.私有化构造函数
		2.声明本类的引用类型变量并且指向本类的对象  (private static)
		3.提供一个公共静态的方法获取本类对象

懒汉单例设计模型：
		1.私有化构造函数
		2.声明本类的引用类型变向对象，但是不要创建对象
		3.提供一个公共静态的方法获取本类对象，"获取之前判断是否已经创建了"，如果没有就重创
-----------------
jdk1.5      自动装箱与自动拆箱

			java 是面向对象语言  
			任何事情都可以使用类进行描述   
			sun就使用了一些类  
			描述java中 八种基本数据类型


		基本数据类型：		包装类型：

			byte			Byte
			short			Short
			int				Integer
			long			Long
			
			float			Float
			double			Double
			
			boolean			Boolean
			
				
			char			Character
	

基本数据类型 有了对应的包装  类型的好处：
	1.字符换成 int 类型数据
	2.数字转换成对应的字符串
	3.整数 转换成对应的 进制
	4.可以吧字符串当成对应的数据  帮你转换

------------------------------
(yi tebo)
Iterator   
 
 jdk1.5  出现
 
 
 
 增强for循环的作用：   
 
 		
 		简化迭代器的书写格式
		（注意： 增强for循环 底层还是使用类迭代器遍历的）
 
 增强 for循环的使用范围  ：
 	
 		如果是实现类 Iterable 接口的对象或者 是 数组对象都可以 增强for循环

 foreach  （fo yiqu）
 
 格式：		 接收的 变量名		
 		for（变量类型 变量名 ： 遍历的目标）{
 		
 		}

注意：（增强for循环）
		1.	底层使用迭代器获取的，  获取迭代器由JVM完成
			所以不可以使用集合对象对集合的元素进行修改
		2.	迭代器遍历元素 	与	增强for循环变量元素		的区别:
					用迭代器遍历元素可以 删除集合的元素
					用增强for循环遍历集合元素时	不可以使用remove方法 删除集合元素
		3.		普通for循环 没有便利的目标
		 		增强for循环一定要有便利的目标
---------------------
	
打 jar 包：需要使用到jdk的开发工具 （ jar.exe ） 

jar的用法

使用格式：
		jar cvf jar文件的名字 class文件或者是文件夹


		注意：
				1.一个程序打完jar之后 必须要在清单文件上指定入口类  格式： Main-class: 包名.类名
				2.jar包双击运行仅对于图形化界面的程序起作用，对控制台的程序不起做用

jar文件的作用：		
				1.方便用户快速运行一个项目
				2.提供工具类给别人使用

如果使用jar包里面的类 必须要先设置 classpath 路径

jre = jvm + 核心类库

package qq;
import javax.swing.*; 
class Love002
{
	public static void main(String[] args) 
	{
		JFrame frame = new JFrame("QQ程序");
		frame.setSize(400,500);
		frame.setVisible(true);// 设置窗口可见
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}


先编译出 .class 文件， 后将 .class 文件 打包成jar 包
{
}
 
F:\Tufo>javac Love002.java

F:\Tufo>javac -d . Love002.java

F:\Tufo>java qq.Love002

F:\Tufo>jar cvf qq.jar qq
已添加清单
正在添加: qq/(输入 = 0) (输出 = 0)(存储了 0%)
正在添加: qq/Love002.class(输入 = 482) (输出 = 360)(压缩了 25%)

